var recursivelySplitGenderAndWord = function(dictDefinition) {
  // split up first item into individual words
  var individualWords = dictDefinition[0].split("_");
  // get rid of gender
  individualWords.pop();
  // rejoin the items with an underscore and add to an array
  var entryWithoutGender = [individualWords.join("_")];
  // base case of recursion
  if (dictDefinition.length == 1) {
    // return first item
    return entryWithoutGender;
  } else {
    // get rid of the first element of the recurssion array
    dictDefinition.shift();
    var arrayElement2 = recursivelySplitGenderAndWord(dictDefinition);
    // return first item and then call the function recursively on the rest, adding
    // it to the array
    return entryWithoutGender.concat(arrayElement2);
  }
}

var returnGenderAndDictionary = function(dictDefinition) {
  var firstWord = dictDefinition[0].split("_");
  var recursiveArrayofDict = recursivelySplitGenderAndWord(dictDefinition);
  return [firstWord[firstWord.length - 1], recursiveArrayofDict];
}

var falseSemantics = function(adjNoise, genderNoise, dictDefinition, state) {
  //split all the gender endings from the dictDefinition
  var recursiveSplit = returnGenderAndDictionary(dictDefinition);
  var dictionaryGender = recursiveSplit[0];
  var dictionaryEntries = recursiveSplit[1];
  // split up gender and state
  var stateArray = state.split("_");
  var wordGender = stateArray.pop();
  var word = stateArray.join("_");

  // if the word (adj) is true
  if (dictionaryEntries.indexOf(word) > -1) {
    // then gender must be false
    return adjNoise*(1-genderNoise);
  } else {
    //else the word is false
    // in which case if gender is true
    if (wordGender == dictionaryGender) {
      return (1-adjNoise)*genderNoise;
    } else {
      // else gender is false
      return (1-adjNoise)*(1-genderNoise);
    }
  }
}